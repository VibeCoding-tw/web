<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Gemini TTS 笑臉按鈕 (跨瀏覽器優化)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 核心深色主題樣式 */
    body { 
        background-color: #1f2937; 
        color: #f9fafb; 
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        display: flex; 
        justify-content: center; 
        align-items: center; 
        min-height: 100vh; 
        margin: 0; 
        padding: 1rem;
    }
    .container-wrap { 
        max-width: 450px; 
        width: 100%; 
        padding: 30px; 
        background-color: #1f2937;
        border-radius: 1.5rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }

    /* 笑臉按鈕容器樣式 (Neumorphic 外凸效果) */
    #smileButton {
        width: 250px;
        height: 250px;
        margin: 0 auto 30px auto; 
        border-radius: 50%;
        cursor: pointer;
        background: #374151; /* 較淺的深灰色作為基底 */
        /* 外凸陰影 */
        box-shadow: 
            8px 8px 16px #1a222c, 
            -8px -8px 16px #3b4555;
        transition: all 0.2s ease;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        touch-action: manipulation;
    }

    /* 按下/啟用時的內凹效果 */
    #smileButton:active, #smileButton.active {
        background: #232d3a;
        /* 內凹陰影 */
        box-shadow: 
            inset 5px 5px 10px #1a222c, 
            inset -5px -5px 10px #3b4555;
        transform: scale(0.98);
    }
    
    /* 內嵌 SVG 笑臉的顏色 */
    .face-svg {
        width: 80%;
        height: 80%;
    }
    
    /* 載入指示器 */
    #loadingSpinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #fcd34d;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s;
    }
    
    #loadingSpinner.visible {
        opacity: 1;
    }

    @keyframes spin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }


    /* 狀態顯示區域 - 預設字體稍微小一點 (1.25rem)，用於語音訊息等 */
    #statusDisplay{
        min-height: 3rem;
        width: 90%;
        padding: 12px; 
        margin: 0 0 30px 0; 
        background: transparent; 
        border-radius: 12px; 
        font-size: 1.25rem; /* 狀態文字變小 */
        font-weight: 700;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: color 0.5s ease, font-size 0.3s ease;
    }
    
    /* Hello World 初始狀態 - 字體變大 */
    #statusDisplay.initial-status {
        font-size: 2rem; /* Hello World 字體變大 */
    }


    /* 返回主選單按鈕 */
    .menu-button {
        display: block;
        width: 90%;
        padding: 12px;
        margin-top: 30px;
        border-radius: 12px;
        border: none;
        background: #4f46e5; 
        color: white;
        font-weight: 700;
        text-align: center;
        text-decoration: none;
        box-shadow: 3px 3px 6px #171d26, -3px -3px 6px #273142;
        transition: all 0.2s ease;
    }
    .menu-button:hover {
        background: #3730a3; 
        box-shadow: 5px 5px 10px #171d26, -5px -5px 10px #273142;
    }
    
    /* 禁用狀態的笑臉按鈕 (在載入音訊時) */
    #smileButton.disabled {
        cursor: not-allowed;
        opacity: 0.7;
    }

  </style>
</head>
<body class="p-4">
    <div class="container-wrap">
        
        <!-- 狀態顯示區 - 移到最上方 -->
        <div id="statusDisplay" class="initial-status">
            <!-- 初始內容將由 JavaScript 設定 -->
        </div>

        <!-- 笑臉按鈕 -->
        <div id="smileButton" role="button" aria-label="Say Hello">
            <!-- SVG 笑臉圖形 -->
            <svg class="face-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <!-- 臉部圓形 (黃色) -->
                <circle cx="50" cy="50" r="48" fill="#FFDA00"/>
                <!-- 左眼 (黑色) -->
                <circle cx="35" cy="35" r="8" fill="#000"/>
                <!-- 右眼 (黑色) -->
                <circle cx="65" cy="35" r="8" fill="#000"/>
                <!-- 嘴巴 (黑色) -->
                <path d="M 25 65 Q 50 85, 75 65" fill="none" stroke="#000" stroke-width="5" stroke-linecap="round"/>
            </svg>
            <!-- 載入指示器 -->
            <div id="loadingSpinner"></div>
        </div>

        
        <!-- 返回主選單按鈕 -->
        <a href="index.html" class="menu-button">
            返回主選單
        </a>
    </div>

<script>
    // ========================================================================
    // DOM Elements & Configuration
    // ========================================================================
    const smileButton = document.getElementById('smileButton');
    const statusDisplay = document.getElementById('statusDisplay');
    const loadingSpinner = document.getElementById('loadingSpinner');
    
    // API Configurations
    const API_URL_BASE = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent';
    const API_KEY = ""; // The API key is injected by the Canvas environment at runtime.

    // Status Texts
    const CLICK_PHRASE = "你好啊！歡迎來到 Vibe Coding 的世界，課程即將開始。"; 
    const INITIAL_PHRASE = "Hello World"; 
    
    // Voice Configuration (Kore is a firm, clear voice)
    const VOICE_NAME = "Kore"; 

    let statusTimeout;
    let isSpeaking = false; // 鎖定狀態，防止重複點擊

    // ========================================================================
    // Audio Utility Functions (No change needed - essential for cross-browser WAV playback)
    // ========================================================================

    /**
     * Helper function: Converts a Base64 string to an ArrayBuffer.
     * @param {string} base64 base64 encoded string
     * @returns {ArrayBuffer} 
     */
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    /**
     * Helper function: Converts PCM 16-bit audio data into a WAV Blob.
     * The Gemini TTS API returns raw PCM data, which needs a WAV header for browser playback.
     * @param {Int16Array} pcm16 16-bit signed PCM data
     * @param {number} sampleRate Sample rate (e.g., 24000)
     * @returns {Blob} WAV format audio Blob
     */
    function pcmToWav(pcm16, sampleRate) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
        const blockAlign = numChannels * (bitsPerSample / 8);
        const dataLength = pcm16.length * (bitsPerSample / 8);
        const buffer = new ArrayBuffer(44 + dataLength);
        const view = new DataView(buffer);
        let offset = 0;

        /* Helper to write string to DataView */
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        /* 1. RIFF Chunk */
        writeString(view, offset, 'RIFF'); offset += 4; // Chunk ID
        view.setUint32(offset, 36 + dataLength, true); offset += 4; // Chunk Size
        writeString(view, offset, 'WAVE'); offset += 4; // Format

        /* 2. fmt Chunk (Format) */
        writeString(view, offset, 'fmt '); offset += 4; // Sub-chunk 1 ID
        view.setUint32(offset, 16, true); offset += 4; // Sub-chunk 1 Size (16 for PCM)
        view.setUint16(offset, 1, true); offset += 2; // Audio Format (1 = PCM)
        view.setUint16(offset, numChannels, true); offset += 2; // Number of Channels
        view.setUint32(offset, sampleRate, true); offset += 4; // Sample Rate
        view.setUint32(offset, byteRate, true); offset += 4; // Byte Rate
        view.setUint16(offset, blockAlign, true); offset += 2; // Block Align
        view.setUint16(offset, bitsPerSample, true); offset += 2; // Bits per Sample

        /* 3. data Chunk */
        writeString(view, offset, 'data'); offset += 4; // Sub-chunk 2 ID
        view.setUint32(offset, dataLength, true); offset += 4; // Sub-chunk 2 Size

        /* Write PCM data (Int16) */
        for (let i = 0; i < pcm16.length; i++) {
            view.setInt16(offset + i * 2, pcm16[i], true); // true for little-endian
        }

        return new Blob([buffer], { type: 'audio/wav' });
    }

    // ========================================================================
    // TTS Logic and Playback (Optimized for Cross-Browser)
    // ========================================================================

    /**
     * Generates and plays audio using the Gemini TTS API.
     * @param {string} text The text to synthesize.
     */
    async function speakText(text) {
        // 在 handleSmileClick 中已檢查 isSpeaking，這裡再次檢查是為了防禦性編程。
        if (isSpeaking) return;

        isSpeaking = true;
        smileButton.classList.add('disabled'); // 禁用按鈕，防止在生成和播放期間被再次點擊
        loadingSpinner.classList.add('visible');
        statusDisplay.classList.remove('initial-status'); // 移除 Hello World 的大字體

        const payload = {
            contents: [{
                parts: [{ text: `Say cheerfully: ${text}` }] // Add style instruction
            }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: VOICE_NAME }
                    }
                }
            },
            model: "gemini-2.5-flash-preview-tts"
        };
        
        const apiUrl = `${API_URL_BASE}?key=${API_KEY}`;
        let response;
        let attempt = 0;
        const maxRetries = 3;

        // Exponential backoff retry logic for robust API call
        while (attempt < maxRetries) {
            try {
                response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    break; 
                } else if (response.status === 429 && attempt < maxRetries - 1) {
                    // Rate limit handling
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    console.warn(`API Rate limit exceeded. Retrying in ${delay / 1000}s...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    attempt++;
                } else {
                    throw new Error(`API Error: ${response.statusText}`);
                }
            } catch (error) {
                if (attempt === maxRetries - 1) {
                    throw error; // Last attempt, rethrow error
                }
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                console.warn(`Fetch Failed. Retrying in ${delay / 1000}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                attempt++;
            }
        }
        
        if (!response || !response.ok) {
            throw new Error("Could not get a valid response from Gemini API.");
        }

        const result = await response.json();
        const part = result?.candidates?.[0]?.content?.parts?.[0];
        const audioData = part?.inlineData?.data;
        const mimeType = part?.inlineData?.mimeType;

        // 確保 MIME Type 是預期的 PCM 格式並包含 Sample Rate
        if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
            const rateMatch = mimeType.match(/rate=(\d+)/);
            if (!rateMatch) throw new Error("Could not extract sample rate from MIME Type.");
            
            const sampleRate = parseInt(rateMatch[1], 10);
            
            // 1. PCM 數據處理
            const pcmData = base64ToArrayBuffer(audioData);
            const pcm16 = new Int16Array(pcmData);
            
            // 2. 轉換為 WAV Blob (這是確保跨瀏覽器兼容性的關鍵步驟)
            const wavBlob = pcmToWav(pcm16, sampleRate);
            const audioUrl = URL.createObjectURL(wavBlob);
            
            // 3. 播放
            const audio = new Audio(audioUrl);
            
            audio.onended = () => {
                // 播放結束，解除鎖定和禁用狀態
                isSpeaking = false;
                smileButton.classList.remove('disabled');
                loadingSpinner.classList.remove('visible');
                URL.revokeObjectURL(audioUrl); // 釋放 Blob URL 資源

                // 在語音播放結束後，等待 7 秒恢復初始狀態
                statusTimeout = setTimeout(() => { 
                    statusDisplay.textContent = INITIAL_PHRASE;
                    statusDisplay.style.color = '#60a5fa'; 
                    statusDisplay.classList.add('initial-status'); // 恢復 Hello World 的大字體
                }, 7000); 
            };

            audio.onerror = (e) => {
                 console.error("Audio playback error:", e);
                 // 發生錯誤，解除鎖定和禁用狀態
                 isSpeaking = false;
                 smileButton.classList.remove('disabled');
                 loadingSpinner.classList.remove('visible');
                 URL.revokeObjectURL(audioUrl);
            }
            
            // 呼叫 play()，這是必須由使用者手勢直接觸發的
            audio.play().catch(e => {
                // 如果播放被阻止 (通常發生在行動裝置，如果手勢連結不夠直接)，會進入這裡
                console.error("Audio playback blocked (requires strict user interaction):", e);
                isSpeaking = false;
                smileButton.classList.remove('disabled');
                loadingSpinner.classList.remove('visible');
                // 由於播放失敗，需要恢復狀態顯示
                statusDisplay.textContent = "播放被阻止 (請再試一次)";
                statusDisplay.style.color = '#f87171'; 
                statusTimeout = setTimeout(() => { 
                    statusDisplay.textContent = INITIAL_PHRASE;
                    statusDisplay.style.color = '#60a5fa'; 
                    statusDisplay.classList.add('initial-status');
                }, 3000); 
            });

        } else {
            throw new Error("Missing or incorrectly formatted audio data in API response.");
        }
    }


    /**
     * Handles the click/touch event on the smiley button.
     * 使用 click 事件確保跨瀏覽器對使用者手勢的識別最為可靠。
     */
    function handleSmileClick() {
        if (isSpeaking) {
             console.log("Still speaking or loading, ignoring click.");
             return;
        }

        // 清除舊的狀態恢復計時器 (如果存在)
        clearTimeout(statusTimeout);
        
        // 在開始生成時，移除大字體類別
        statusDisplay.classList.remove('initial-status');

        statusDisplay.textContent = "正在生成語音...";
        statusDisplay.style.color = '#fcd34d'; 
        
        speakText(CLICK_PHRASE)
            .then(() => {
                console.log("TTS Generation successful.");
            })
            .catch(error => {
                console.error("TTS Generation Failed:", error);
                // 錯誤處理：恢復狀態
                statusDisplay.textContent = "語音失敗 (API 錯誤)";
                statusDisplay.style.color = '#f87171'; 
                isSpeaking = false;
                smileButton.classList.remove('disabled');
                loadingSpinner.classList.remove('visible');
                // 失敗時，讓錯誤訊息停留一下，然後恢復初始狀態
                statusTimeout = setTimeout(() => { 
                    statusDisplay.textContent = INITIAL_PHRASE;
                    statusDisplay.style.color = '#60a5fa'; 
                    statusDisplay.classList.add('initial-status'); 
                }, 3000); 
            });
            
        // 快速顯示即將播放的文字，提供更即時的回饋
        setTimeout(() => {
            if(statusDisplay.textContent === "正在生成語音...") {
                statusDisplay.textContent = CLICK_PHRASE;
            }
        }, 300);
        
    }

    // ========================================================================
    // Event Bindings (Optimized)
    // ========================================================================
    
    // 1. 核心動作：使用 click 事件，它適用於所有裝置 (滑鼠點擊或觸控結束)
    smileButton.addEventListener('click', handleSmileClick); 

    // 2. 視覺回饋：使用 pointerdown/up 來處理按鈕的內凹視覺效果
    smileButton.addEventListener('pointerdown', (e) => {
        // 僅處理視覺效果。實際的語音生成由 'click' 事件觸發。
        if (isSpeaking) return;
        e.preventDefault();
        smileButton.classList.add('active');
    });
    
    smileButton.addEventListener('pointerup', () => {
        smileButton.classList.remove('active');
    });
    
    smileButton.addEventListener('pointercancel', () => {
        smileButton.classList.remove('active');
    });


    // Initial state setup on page load
    window.onload = () => {
        statusDisplay.textContent = INITIAL_PHRASE;
        statusDisplay.style.color = '#60a5fa'; 
        statusDisplay.classList.add('initial-status'); 
        isSpeaking = false;
        smileButton.classList.remove('disabled');
        loadingSpinner.classList.remove('visible');
    };

</script>
</body>
</html>