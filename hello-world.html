<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>Gemini TTS 笑臉按鈕 (Web Audio API)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 核心深色主題樣式 */
    body { 
        background-color: #1f2937; 
        color: #f9fafb; 
        font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
        display: flex; 
        justify-content: center; 
        align-items: center; 
        min-height: 100vh; 
        margin: 0; 
        padding: 1rem;
    }
    .container-wrap { 
        max-width: 450px; 
        width: 100%; 
        padding: 30px; 
        background-color: #1f2937;
        border-radius: 1.5rem;
        display: flex;
        flex-direction: column;
        align-items: center;
        text-align: center;
    }

    /* 笑臉按鈕容器樣式 (Neumorphic 外凸效果) */
    #smileButton {
        width: 250px;
        height: 250px;
        margin: 0 auto 30px auto; 
        border-radius: 50%;
        cursor: pointer;
        background: #374151; /* 較淺的深灰色作為基底 */
        /* 外凸陰影 */
        box-shadow: 
            8px 8px 16px #1a222c, 
            -8px -8px 16px #3b4555;
        transition: all 0.2s ease;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        user-select: none;
        touch-action: manipulation;
    }

    /* 按下/啟用時的內凹效果 */
    #smileButton:active, #smileButton.active {
        background: #232d3a;
        /* 內凹陰影 */
        box-shadow: 
            inset 5px 5px 10px #1a222c, 
            inset -5px -5px 10px #3b4555;
        transform: scale(0.98);
    }
    
    /* 內嵌 SVG 笑臉的顏色 */
    .face-svg {
        width: 80%;
        height: 80%;
    }
    
    /* 載入指示器 */
    #loadingSpinner {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: 50px;
        height: 50px;
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid #fcd34d;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        z-index: 10;
        opacity: 0;
        transition: opacity 0.3s;
    }
    
    #loadingSpinner.visible {
        opacity: 1;
    }

    @keyframes spin {
        0% { transform: translate(-50%, -50%) rotate(0deg); }
        100% { transform: translate(-50%, -50%) rotate(360deg); }
    }


    /* 狀態顯示區域 - 預設字體稍微小一點 (1.25rem)，用於語音訊息等 */
    #statusDisplay{
        min-height: 3rem;
        width: 90%;
        padding: 12px; 
        margin: 0 0 30px 0; 
        background: transparent; 
        border-radius: 12px; 
        font-size: 1.25rem; /* 狀態文字變小 */
        font-weight: 700;
        display: flex;
        justify-content: center;
        align-items: center;
        transition: color 0.5s ease, font-size 0.3s ease;
    }
    
    /* Hello World 初始狀態 - 字體變大 */
    #statusDisplay.initial-status {
        font-size: 2rem; /* Hello World 字體變大 */
    }


    /* 返回主選單按鈕 */
    .menu-button {
        display: block;
        width: 90%;
        padding: 12px;
        margin-top: 30px;
        border-radius: 12px;
        border: none;
        background: #4f46e5; 
        color: white;
        font-weight: 700;
        text-align: center;
        text-decoration: none;
        box-shadow: 3px 3px 6px #171d26, -3px -3px 6px #273142;
        transition: all 0.2s ease;
    }
    .menu-button:hover {
        background: #3730a3; 
        box-shadow: 5px 5px 10px #171d26, -5px -5px 10px #273142;
    }
    
    /* 禁用狀態的笑臉按鈕 (在載入音訊時) */
    #smileButton.disabled {
        cursor: not-allowed;
        opacity: 0.7;
    }

  </style>
</head>
<body class="p-4">
    <div class="container-wrap">
        
        <!-- 狀態顯示區 - 移到最上方 -->
        <div id="statusDisplay" class="initial-status">
            <!-- 初始內容將由 JavaScript 設定 -->
        </div>

        <!-- 笑臉按鈕 -->
        <div id="smileButton" role="button" aria-label="Say Hello">
            <!-- SVG 笑臉圖形 -->
            <svg class="face-svg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
                <!-- 臉部圓形 (黃色) -->
                <circle cx="50" cy="50" r="48" fill="#FFDA00"/>
                <!-- 左眼 (黑色) -->
                <circle cx="35" cy="35" r="8" fill="#000"/>
                <!-- 右眼 (黑色) -->
                <circle cx="65" cy="35" r="8" fill="#000"/>
                <!-- 嘴巴 (黑色) -->
                <path d="M 25 65 Q 50 85, 75 65" fill="none" stroke="#000" stroke-width="5" stroke-linecap="round"/>
            </svg>
            <!-- 載入指示器 -->
            <div id="loadingSpinner"></div>
        </div>

        
        <!-- 返回主選單按鈕 -->
        <a href="index.html" class="menu-button">
            返回主選單
        </a>
    </div>

<script>
    // ========================================================================
    // DOM Elements & Configuration
    // ========================================================================
    const smileButton = document.getElementById('smileButton');
    const statusDisplay = document.getElementById('statusDisplay');
    const loadingSpinner = document.getElementById('loadingSpinner');
    
    // API Configurations
    const API_URL_BASE = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent';
    const API_KEY = ""; // API key will be injected by the Canvas environment at runtime.

    // Status Texts
    const CLICK_PHRASE = "你好啊！歡迎來到 Vibe Coding 的世界，課程即將開始。"; 
    const INITIAL_PHRASE = "Hello World"; 
    
    // Voice Configuration (Kore is a firm, clear voice)
    const VOICE_NAME = "Kore"; 

    let statusTimeout;
    let isSpeaking = false; 

    // ========================================================================
    // Audio Utility Functions
    // ========================================================================

    /**
     * Helper function: Converts a Base64 string to an ArrayBuffer.
     * @param {string} base64 base64 encoded string
     * @returns {ArrayBuffer} 
     */
    function base64ToArrayBuffer(base64) {
        const binaryString = atob(base64);
        const len = binaryString.length;
        const bytes = new Uint8Array(len);
        for (let i = 0; i < len; i++) {
            bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
    }

    /**
     * Helper function: Converts PCM 16-bit audio data into a WAV Blob.
     * @param {Int16Array} pcm16 16-bit signed PCM data
     * @param {number} sampleRate Sample rate (e.g., 24000)
     * @returns {Blob} WAV format audio Blob
     */
    function pcmToWav(pcm16, sampleRate) {
        const numChannels = 1;
        const bitsPerSample = 16;
        const byteRate = sampleRate * numChannels * (bitsPerSample / 8);
        const blockAlign = numChannels * (bitsPerSample / 8);
        const dataLength = pcm16.length * (bitsPerSample / 8);
        const buffer = new ArrayBuffer(44 + dataLength);
        const view = new DataView(buffer);
        let offset = 0;

        /* Helper to write string to DataView */
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        /* 1. RIFF Chunk */
        writeString(view, offset, 'RIFF'); offset += 4; // Chunk ID
        view.setUint32(offset, 36 + dataLength, true); offset += 4; // Chunk Size
        writeString(view, offset, 'WAVE'); offset += 4; // Format

        /* 2. fmt Chunk (Format) */
        writeString(view, offset, 'fmt '); offset += 4; // Sub-chunk 1 ID
        view.setUint32(offset, 16, true); offset += 4; // Sub-chunk 1 Size (16 for PCM)
        view.setUint16(offset, 1, true); offset += 2; // Audio Format (1 = PCM)
        view.setUint16(offset, numChannels, true); offset += 2; // Number of Channels
        view.setUint32(offset, sampleRate, true); offset += 4; // Sample Rate
        view.setUint32(offset, byteRate, true); offset += 4; // Byte Rate
        view.setUint16(offset, blockAlign, true); offset += 2; // Block Align
        view.setUint16(offset, bitsPerSample, true); offset += 2; // Bits per Sample

        /* 3. data Chunk */
        writeString(view, offset, 'data'); offset += 4; // Sub-chunk 2 ID
        view.setUint32(offset, dataLength, true); offset += 4; // Sub-chunk 2 Size

        /* Write PCM data (Int16) */
        for (let i = 0; i < pcm16.length; i++) {
            view.setInt16(offset + i * 2, pcm16[i], true); // true for little-endian
        }

        return new Blob([buffer], { type: 'audio/wav' });
    }

    // ========================================================================
    // TTS Logic and Playback (Web Audio API for iOS Compatibility)
    // ========================================================================

    /**
     * Generates and plays audio using the Gemini TTS API.
     * @param {string} text The text to synthesize.
     */
    async function speakText(text) {
        if (isSpeaking) return;

        isSpeaking = true;
        smileButton.classList.add('disabled'); 
        loadingSpinner.classList.add('visible');
        statusDisplay.classList.remove('initial-status');

        const payload = {
            contents: [{
                parts: [{ text: `Say cheerfully: ${text}` }] // 加入語氣指令
            }],
            generationConfig: {
                responseModalities: ["AUDIO"],
                speechConfig: {
                    voiceConfig: {
                        prebuiltVoiceConfig: { voiceName: VOICE_NAME }
                    }
                }
            },
            model: "gemini-2.5-flash-preview-tts"
        };
        
        const apiUrl = `${API_URL_BASE}?key=${API_KEY}`;
        let response;
        let attempt = 0;
        const maxRetries = 3;

        // 帶有指數退避的 API 呼叫邏輯
        while (attempt < maxRetries) {
            try {
                response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (response.ok) {
                    break; 
                } else if (response.status === 429 && attempt < maxRetries - 1) {
                    const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                    console.warn(`API 頻率限制，將於 ${delay / 1000} 秒後重試...`);
                    await new Promise(resolve => setTimeout(resolve, delay));
                    attempt++;
                } else {
                    throw new Error(`API 錯誤: ${response.statusText}`);
                }
            } catch (error) {
                if (attempt === maxRetries - 1) {
                    throw error; 
                }
                const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                console.warn(`Fetch 失敗，將於 ${delay / 1000} 秒後重試...`);
                await new Promise(resolve => setTimeout(resolve, delay));
                attempt++;
            }
        }
        
        if (!response || !response.ok) {
            throw new Error("未能從 Gemini API 獲得有效回應。");
        }

        const result = await response.json();
        const part = result?.candidates?.[0]?.content?.parts?.[0];
        const audioData = part?.inlineData?.data;
        const mimeType = part?.inlineData?.mimeType;

        if (audioData && mimeType && mimeType.startsWith("audio/L16")) {
            const rateMatch = mimeType.match(/rate=(\d+)/);
            if (!rateMatch) throw new Error("無法從 MIME Type 中提取取樣率。");
            
            const sampleRate = parseInt(rateMatch[1], 10);
            
            // 1. PCM 數據處理
            const pcmData = base64ToArrayBuffer(audioData);
            const pcm16 = new Int16Array(pcmData);
            
            // 2. 轉換為 WAV Blob
            const wavBlob = pcmToWav(pcm16, sampleRate);
            
            // 3. **核心改動：使用 Web Audio API 播放 (更適用於 iOS/Safari)**
            const reader = new FileReader();

            reader.onload = async (e) => {
                const arrayBuffer = e.target.result;
                // 必須在使用者互動的事件處理中創建 AudioContext
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const audioContext = new AudioContext();

                try {
                    // 解碼音訊數據
                    const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                    
                    // 創建音源節點
                    const source = audioContext.createBufferSource();
                    source.buffer = audioBuffer;
                    source.connect(audioContext.destination);

                    // 設置播放結束後的清理邏輯
                    source.onended = () => {
                        // 清理狀態
                        isSpeaking = false;
                        smileButton.classList.remove('disabled');
                        loadingSpinner.classList.remove('visible');
                        
                        // 恢復初始狀態
                        statusTimeout = setTimeout(() => { 
                            statusDisplay.textContent = INITIAL_PHRASE;
                            statusDisplay.style.color = '#60a5fa'; 
                            statusDisplay.classList.add('initial-status'); 
                        }, 7000); 
                    };

                    // 啟動播放 (必須直接在使用者事件內完成)
                    source.start(0);

                } catch (error) {
                    console.error("Web Audio 解碼或播放失敗:", error);
                    // 播放失敗，執行錯誤清理邏輯
                    isSpeaking = false;
                    smileButton.classList.remove('disabled');
                    loadingSpinner.classList.remove('visible');
                    statusDisplay.textContent = "播放失敗 (Web Audio 錯誤)";
                    statusDisplay.style.color = '#f87171'; 
                    statusTimeout = setTimeout(() => { 
                        statusDisplay.textContent = INITIAL_PHRASE;
                        statusDisplay.style.color = '#60a5fa'; 
                        statusDisplay.classList.add('initial-status');
                    }, 3000); 
                }
            };
            
            // 將 Blob 讀取為 ArrayBuffer，然後觸發 onload
            reader.readAsArrayBuffer(wavBlob);

        } else {
            throw new Error("API 回應中缺少或格式不正確的音訊數據。");
        }
    }


    // ========================================================================
    // Event Bindings
    // ========================================================================

    /**
     * Handles the click/touch event on the smiley button.
     */
    function handleSmileClick() {
        if (isSpeaking) {
             console.log("正在發言或加載，忽略點擊。");
             return;
        }

        // 清除舊的狀態恢復計時器
        clearTimeout(statusTimeout);
        
        statusDisplay.classList.remove('initial-status');

        statusDisplay.textContent = "正在生成語音...";
        statusDisplay.style.color = '#fcd34d'; 
        
        // 快速顯示即將播放的文字
        setTimeout(() => {
            if(statusDisplay.textContent === "正在生成語音...") {
                statusDisplay.textContent = CLICK_PHRASE;
            }
        }, 300);

        speakText(CLICK_PHRASE)
            .then(() => {
                console.log("TTS 生成成功。");
            })
            .catch(error => {
                console.error("TTS 生成失敗:", error);
                // 錯誤處理：恢復狀態
                statusDisplay.textContent = "語音失敗 (API 錯誤)";
                statusDisplay.style.color = '#f87171'; 
                isSpeaking = false;
                smileButton.classList.remove('disabled');
                loadingSpinner.classList.remove('visible');
                
                statusTimeout = setTimeout(() => { 
                    statusDisplay.textContent = INITIAL_PHRASE;
                    statusDisplay.style.color = '#60a5fa'; 
                    statusDisplay.classList.add('initial-status'); 
                }, 3000); 
            });
        
    }

    // 1. 核心動作：使用 click 事件
    smileButton.addEventListener('click', handleSmileClick); 

    // 2. 視覺回饋：使用 pointerdown/up 處理按鈕的內凹視覺效果
    smileButton.addEventListener('pointerdown', (e) => {
        if (isSpeaking) return;
        e.preventDefault();
        smileButton.classList.add('active');
    });
    
    smileButton.addEventListener('pointerup', () => {
        smileButton.classList.remove('active');
    });
    
    smileButton.addEventListener('pointercancel', () => {
        smileButton.classList.remove('active');
    });


    // Initial state setup on page load
    window.onload = () => {
        statusDisplay.textContent = INITIAL_PHRASE;
        statusDisplay.style.color = '#60a5fa'; 
        statusDisplay.classList.add('initial-status'); 
        isSpeaking = false;
        smileButton.classList.remove('disabled');
        loadingSpinner.classList.remove('visible');
    };

</script>
</body>
</html>