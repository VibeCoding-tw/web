<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
<title>BLE èªéŸ³æ§åˆ¶ (Mobile)</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
/* ç¢ºä¿å…¨è¢å¹•é«˜åº¦å’ŒæŸ”è»Ÿçš„èƒŒæ™¯è‰² */
body {
background-color: #1f2937;
color: #f9fafb;
font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif;
display: flex;
justify-content: center;
align-items: center;
min-height: 100vh;
margin: 0;
padding: 1rem;
}
.container-wrap {
max-width: 400px;
width: 100%;
padding: 20px;
background-color: #1f2937; /* èˆ‡ body èƒŒæ™¯ä¸€è‡´ */
border-radius: 1rem;
box-shadow: 10px 10px 20px #171d26, -10px -10px 20px #273142;
}
/* é ‚éƒ¨æ§åˆ¶åˆ— */
.top{width:100%;display:flex;gap:8px;align-items:center; max-width: 520px; margin-bottom: 20px;}
button{padding:10px 14px;border-radius:12px;border:none;background:#4f46e5;color:white;font-weight:700;box-shadow: 3px 3px 6px #1a202c, -3px -3px 6px #273142; transition: all 0.15s ease-in-out; white-space: nowrap;}
button:hover { background: #3730a3; box-shadow: 5px 5px 10px #1a202c, -5px -5px 10px #273142;}
button:disabled { background: #4b5563; cursor: not-allowed; box-shadow: none; }

#status{flex:1;text-align:center;font-weight:700;color:#f9fafb; padding: 10px; background: #2d3748; border-radius: 12px; box-shadow: inset 3px 3px 6px #1a202c, inset -3px -3px 6px #273142;}

/* ç‹€æ…‹æ–‡å­— */
#main-status { font-weight: 700; text-shadow: 0 0 5px rgba(79, 70, 229, 0.5); }
.info{font-size:14px;color:#9ca3af; margin-top: 20px;}

/* èªéŸ³æ§åˆ¶æŒ‰éˆ•æ¨£å¼ */
#btnSpeech {
background-color: #ef4444; /* ç´…è‰² */
color: white;
font-size: 1.25rem;
padding: 1.5rem;
width: 100%;
height: 150px;
display: flex;
flex-direction: column;
align-items: center;
justify-content: center;
margin-top: 20px;
box-shadow: 5px 5px 10px #1a202c, -5px -5px 10px #273142;
transition: all 0.3s ease-in-out;
}
#btnSpeech.listening {
background-color: #10b981; /* ç¶ è‰² */
box-shadow: 0 0 10px #10b981, 0 0 20px #10b981;
animation: pulse 2s infinite cubic-bezier(0.4, 0, 0.6, 1);
}
#btnSpeech.disabled {
background-color: #4b5563;
animation: none;
cursor: not-allowed;
box-shadow: none;
}
@keyframes pulse {
0%, 100% { opacity: 1; }
50% { opacity: .7; }
}
.speech-subtext { font-size: 0.8rem; margin-top: 0.5rem; }

#speech-result {
min-height: 2.5rem;
padding: 10px;
background: #2d3748;
border-radius: 8px;
margin-top: 15px;
font-style: italic;
text-align: center;
}
</style>
</head>
<body class="p-4">
<div class="container-wrap">

<h1 class="text-3xl font-extrabold text-center text-indigo-400 mb-6">ğŸ™ï¸ BLE èªéŸ³æ§åˆ¶</h1>

<div class="top">
<button id="btnConnect" class="flex-grow">é€£ç·š BLE</button>
<div id="status">æœªé€£ç·š</div>
</div>

<button id="btnSpeech" disabled class="disabled">
<span id="speechMainText">è«‹é€£ç·š BLE è£ç½®</span>
<span id="speechSubText" class="speech-subtext"></span>
</button>

<div id="speech-result" class="text-center text-gray-400">
èªªå‡º: å‰é€² | å¾Œé€€ | å·¦è½‰ | å³è½‰ | åœæ­¢
</div>

<div class="text-center space-y-2 mt-4">
<p class="text-xl">ç›®å‰å‘½ä»¤: <span id="main-status" class="text-green-400">éœæ­¢</span></p>
<p class="text-xs text-gray-500">
T (é€Ÿåº¦): <span id="val_t">0</span> | S (è½‰å‘): <span id="val_s">0</span>
</p>
</div>
</div>

<script>
// --- BLE & Control Configuration ---
const SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-000000000000';Â 
const CHARACTERISTIC_UUID = '4fafc201-1fb5-459e-8fcc-000000000000';Â 
const DEVICE_ID_KEY = 'ble_joystick_device_id';Â 
const MAX_CONTROL_VALUE = 255;Â 

// èªéŸ³å‘½ä»¤å°æ‡‰çš„é¦¬é”æ§åˆ¶å€¼ (T, S)
const COMMANDS = {
    "å‰é€²": {t: MAX_CONTROL_VALUE, s: 0, status: "å‰é€²ä¸­", color: "text-green-400"},
    "å¾Œé€€": {t: -MAX_CONTROL_VALUE, s: 0, status: "å¾Œé€€ä¸­", color: "text-orange-400"},
    "å·¦è½‰": {t: 0, s: -MAX_CONTROL_VALUE, status: "å·¦è½‰ä¸­", color: "text-blue-400"},
    "å³è½‰": {t: 0, s: MAX_CONTROL_VALUE, status: "å³è½‰ä¸­", color: "text-blue-400"},
    "åœæ­¢": {t: 0, s: 0, status: "éœæ­¢", color: "text-red-400"},
    "åœ": {t: 0, s: 0, status: "éœæ­¢", color: "text-red-400"}, // å¢åŠ ã€Œåœã€ä½œç‚ºåˆ¥å
};
const COMMAND_KEYWORDS = Object.keys(COMMANDS);


// --- DOM Elements ---
const statusEl = document.getElementById('status'); // BLE é€£ç·šç‹€æ…‹
const mainStatusEl = document.getElementById('main-status'); // ç›®å‰å‘½ä»¤ç‹€æ…‹
const valTEl = document.getElementById('val_t'); // T (Throttle)
const valSEl = document.getElementById('val_s'); // S (Steer)
const btnConnect = document.getElementById('btnConnect');
const btnSpeech = document.getElementById('btnSpeech'); // èªéŸ³æ§åˆ¶æŒ‰éˆ•
const speechMainTextEl = document.getElementById('speechMainText');
const speechSubTextEl = document.getElementById('speechSubText');
const speechResultEl = document.getElementById('speech-result');

// ç‚ºäº†æ›´å»£æ³›çš„ç€è¦½å™¨ç›¸å®¹æ€§ï¼Œä½¿ç”¨å‰ç¶´
const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;

// --- State Variables ---
let device = null;
let characteristic = null;
let lastPayload = {t: 0, s: 0}; // å„²å­˜ä¸Šæ¬¡ç™¼é€çš„ T, S å€¼

let recognition = null;
let isListening = false;
/**
 * @type {boolean} autoRestartRecognition - ç•¶ BLE é€£ç·šä¸­æ™‚ï¼Œè¨­ç‚º trueï¼ŒèªéŸ³è¾¨è­˜æœƒè‡ªå‹•é‡å•Ÿã€‚
 */
let autoRestartRecognition = false;


// --- Helper Functions ---

/**
 * æ›´æ–°é¦¬é”æ•¸å€¼ä¸¦ç™¼é€å‘½ä»¤
 * @param {number} t é€Ÿåº¦å€¼ (-255 åˆ° 255)
 * @param {number} s è½‰å‘å€¼ (-255 åˆ° 255)
 * @param {string} statusText é¡¯ç¤ºåœ¨ UI ä¸Šçš„å‘½ä»¤ç‹€æ…‹
 * @param {string} statusColor ç‹€æ…‹æ–‡å­—é¡è‰²
 */
async function updateMotorValues(t, s, statusText, statusColor) {
    lastPayload.t = t;
    lastPayload.s = s;

    // æ›´æ–° UI é¡¯ç¤º
    valTEl.textContent = t;
    valSEl.textContent = s;
    mainStatusEl.textContent = statusText;
    mainStatusEl.className = `font-bold ${statusColor}`;

    // ç«‹å³ç™¼é€æ§åˆ¶å‘½ä»¤
    await sendControl();
}

/**
 * è™•ç†èªéŸ³è¾¨è­˜çš„çµæœ
 */
function processSpeechResult(transcript) {
    speechResultEl.textContent = `è¾¨è­˜çµæœ: ${transcript}`;

    // æª¢æŸ¥æ˜¯å¦åŒ…å«ä»»ä½•å‘½ä»¤é—œéµå­—
    for (const keyword of COMMAND_KEYWORDS) {
        if (transcript.includes(keyword)) {
            const command = COMMANDS[keyword];
            updateMotorValues(command.t, command.s, command.status, command.color);
            speechResultEl.textContent = `âœ… å‘½ä»¤åŸ·è¡Œ: ${keyword}`;
            return; // æ‰¾åˆ°ç¬¬ä¸€å€‹å‘½ä»¤å°±åŸ·è¡Œä¸¦è¿”å›
        }
    }

    // å¦‚æœæ²’æœ‰åŒ¹é…çš„å‘½ä»¤ï¼Œåªæ›´æ–°çµæœï¼Œä¸åœæ­¢é¦¬é” (å¯èƒ½åœ¨ç­‰ä¸‹ä¸€å€‹æŒ‡ä»¤)
    speechResultEl.textContent = `âš ï¸ ç„¡æ•ˆå‘½ä»¤: ${transcript} (è«‹é‡è©¦)`;
    // updateMotorValues(0, 0, "éœæ­¢", "text-red-400"); // é¿å…ç„¡æ•ˆå‘½ä»¤ç«‹å³åœæ­¢
}


// --- Web Speech API (Speech Recognition) Logic ---

/**
 * æ ¹æ“šé€£ç·šå’Œè†è½ç‹€æ…‹æ›´æ–°èªéŸ³æŒ‰éˆ• UI
 * @param {boolean} listening - æ˜¯å¦æ­£åœ¨è†è½
 * @param {boolean} connected - æ˜¯å¦å·²é€£ç·š BLE
 */
function updateSpeechUI(listening, connected) {
    btnSpeech.disabled = !connected;
    btnSpeech.classList.toggle('disabled', !connected);
    btnSpeech.classList.toggle('listening', listening);
    isListening = listening;

    if (!connected) {
        speechMainTextEl.textContent = "è«‹é€£ç·š BLE è£ç½®";
        speechSubTextEl.textContent = "é€£ç·šå¾Œè‡ªå‹•é–‹å§‹èªéŸ³æ§åˆ¶";
    } else if (listening) {
        speechMainTextEl.textContent = "èªéŸ³æ§åˆ¶å•Ÿç”¨ä¸­";
        speechSubTextEl.textContent = "è«‹å°è‘—éº¥å…‹é¢¨èªªè©±...";
    } else {
        speechMainTextEl.textContent = "èªéŸ³å·²æš«åœ (æ‰‹å‹•/éŒ¯èª¤)";
        speechSubTextEl.textContent = "é»æ“Šæ­¤è™•å¯é‡æ–°å•Ÿå‹•";
    }
}

/**
 * åˆå§‹åŒ–èªéŸ³è¾¨è­˜ç‰©ä»¶ä¸¦è¨­å®šäº‹ä»¶è™•ç†å™¨
 */
function initSpeechRecognition() {
    if (!SpeechRecognition) {
        alert("âŒ æ‚¨çš„ç€è¦½å™¨ä¸æ”¯æ´ Web Speech API (èªéŸ³è¾¨è­˜)ã€‚è«‹ä½¿ç”¨ Chrome æˆ– Edge ç€è¦½å™¨ã€‚");
        btnSpeech.disabled = true;
        return;
    }
    if (recognition) return;

    recognition = new SpeechRecognition();
    recognition.continuous = false; // åªè½ä¸€å€‹æŒ‡ä»¤
    recognition.lang = 'zh-Hant'; // è¨­å®šç‚ºç¹é«”ä¸­æ–‡
    recognition.interimResults = false; // åªè¿”å›æœ€çµ‚çµæœ

    recognition.onstart = () => {
        // åªæœ‰åœ¨é€£ç·šæ™‚æ‰æ›´æ–°ç‚º Listening ç‹€æ…‹
        if (device && device.gatt && device.gatt.connected) {
            updateSpeechUI(true, true);
        }
    };

    recognition.onresult = (event) => {
        const transcript = event.results[0][0].transcript;
        processSpeechResult(transcript);
        // Note: recognition.onend æœƒç·Šæ¥è‘— onresult ä¹‹å¾Œè§¸ç™¼
    };

    recognition.onerror = (event) => {
        console.error('Speech recognition error:', event.error);
        if (event.error !== 'no-speech' && event.error !== 'audio-capture') {
            speechResultEl.textContent = `âŒ èªéŸ³éŒ¯èª¤: ${event.error}`;
        }
        // onend æœƒåœ¨ error ä¹‹å¾Œè§¸ç™¼ï¼Œè®“ onend è™•ç†é‡å•Ÿé‚è¼¯
    };

    recognition.onend = () => {
        // æ ¸å¿ƒé‚è¼¯ï¼šå¦‚æœ BLE ä»åœ¨é€£ç·šä¸­ (autoRestartRecognition=true)ï¼Œå‰‡è‡ªå‹•é‡å•Ÿ
        if (autoRestartRecognition) {
            // ä½¿ç”¨ setTimeout é¿å… onend ç«‹å³é‡å•Ÿå°è‡´çš„éŒ¯èª¤
            setTimeout(startSpeechRecognition, 100);
        } else {
            // å¦‚æœæ˜¯æ‰‹å‹•åœæ­¢æˆ– BLE æ–·ç·šï¼Œæ›´æ–° UI ç‚ºéè†è½ç‹€æ…‹
            updateSpeechUI(false, false);
        }
    };
}

/**
 * å•Ÿå‹•èªéŸ³è¾¨è­˜
 */
function startSpeechRecognition() {
    initSpeechRecognition();
    if (!device || !device.gatt.connected) {
        statusEl.textContent = 'è«‹å…ˆé€£ç·š BLE è£ç½®ã€‚';
        return;
    }
    if (isListening) return; // å·²ç¶“åœ¨è†è½ä¸­ï¼Œä¸é‡è¤‡å•Ÿå‹•

    try {
        recognition.start();
        // UI æ›´æ–°å°‡åœ¨ recognition.onstart ä¸­è™•ç†
    } catch (e) {
        console.warn('Recognition start failed (already started or error):', e);
        // å¦‚æœå·²ç¶“å•Ÿå‹•ï¼Œå¿½ç•¥éŒ¯èª¤
    }
}

/**
 * åœæ­¢èªéŸ³è¾¨è­˜
 */
function stopSpeechRecognition() {
    if (recognition && isListening) {
        // åœæ­¢å¾Œï¼Œrecognition.onend æœƒè§¸ç™¼
        recognition.stop();
    }
    // ç¢ºä¿ autoRestart è¢«è¨­ç‚º falseï¼Œé˜»æ­¢ onend è‡ªå‹•é‡å•Ÿ
    autoRestartRecognition = false;
    updateSpeechUI(false, false);
}

/**
 * èªéŸ³æŒ‰éˆ•çš„é»æ“Šè™•ç† (ç¾åœ¨ä¸»è¦ç”¨æ–¼æ‰‹å‹•å•Ÿå‹•/åœæ­¢çš„è¦†è“‹)
 */
function handleSpeechButtonClick() {
    if (!device || !device.gatt.connected) {
        statusEl.textContent = 'è«‹å…ˆé€£ç·š BLE è£ç½®ã€‚';
        return;
    }

    if (isListening) {
        // æ‰‹å‹•é»æ“Šåœæ­¢ï¼Œæš«æ™‚ç¦ç”¨è‡ªå‹•é‡å•Ÿ
        autoRestartRecognition = false;
        stopSpeechRecognition();
    } else {
        // æ‰‹å‹•é»æ“Šå•Ÿå‹•ï¼Œé‡æ–°å•Ÿç”¨è‡ªå‹•é‡å•Ÿ
        autoRestartRecognition = true;
        startSpeechRecognition();
    }
}


// --- BLE Connection Logic ---

/**
 * BLE æ–·ç·šäº‹ä»¶è™•ç†
 */
function onDisconnect() {
    // 1. åœæ­¢èªéŸ³æ§åˆ¶ä¸¦ç¦ç”¨è‡ªå‹•é‡å•Ÿ
    stopSpeechRecognition();

    // 2. åœæ­¢é¦¬é”
    updateMotorValues(0, 0, "å·²æ–·ç·šï¼Œéœæ­¢", "text-gray-500");

    // 3. æ›´æ–° BLE ç‹€æ…‹
    statusEl.textContent = 'âŒ å·²æ–·ç·š';
    btnConnect.textContent = 'é€£ç·š BLE';
    if (device) device.removeEventListener('gattserverdisconnected', onDisconnect);
    
    device = null;
    characteristic = null;
}

async function acquireDevice() {
    statusEl.textContent = 'æƒæä¸­ (éæ¿¾: esp32)...';
    // æœå°‹åç¨±å‰ç¶´ç‚º 'esp32' ä¸”åŒ…å«æŒ‡å®šæœå‹™ UUID çš„è£ç½®
    const newDevice = await navigator.bluetooth.requestDevice({
        filters:[{ namePrefix: 'esp32' }],
        optionalServices: [SERVICE_UUID]
    });

    localStorage.setItem(DEVICE_ID_KEY, newDevice.id);
    return newDevice;
}


async function connectBLE(){
    if (!navigator.bluetooth) {
        statusEl.textContent = 'âŒ ç€è¦½å™¨ä¸æ”¯æ´ Web Bluetoothã€‚';
        return;
    }

    // è™•ç†å·²é€£ç·šç‹€æ…‹ä¸‹çš„æŒ‰éˆ•é»æ“Š (æ–·é–‹é€£ç·š)
    if (device && device.gatt && device.gatt.connected) {
        statusEl.textContent = 'ä¸­æ–·é€£ç·šä¸­...';
        device.gatt.disconnect(); // é€™æœƒè§¸ç™¼ onDisconnect äº‹ä»¶
        return;
    }

    try{
        device = await acquireDevice();
        if (!device) throw new Error("è£ç½®æœªé€£ç·šæˆ–æœªæ‰¾åˆ°ã€‚");

        statusEl.textContent = `é€£ç·šåˆ° ${device.name}...`;

        // è¨­ç½®æ–·ç·šç›£è½å™¨ (å…ˆç§»é™¤èˆŠçš„ï¼Œå†æ–°å¢æ–°çš„ï¼Œç¢ºä¿åªåŸ·è¡Œä¸€æ¬¡)
        device.removeEventListener('gattserverdisconnected', onDisconnect);
        device.addEventListener('gattserverdisconnected', onDisconnect);

        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);

        // --- é€£ç·šæˆåŠŸå¾Œçš„æ ¸å¿ƒæ­¥é©Ÿ ---
        statusEl.textContent = 'âœ… å·²é€£ç·š: ' + device.name;
        btnConnect.textContent = 'æ–·é–‹';

        // 1. å•Ÿç”¨èªéŸ³æ§åˆ¶çš„è‡ªå‹•é‡å•Ÿæ©Ÿåˆ¶
        autoRestartRecognition = true;
        // 2. è‡ªå‹•å•Ÿå‹•èªéŸ³æ§åˆ¶ (æ»¿è¶³ä½¿ç”¨è€…éœ€æ±‚)
        startSpeechRecognition();
        
        updateSpeechUI(isListening, true); // æ›´æ–°èªéŸ³æŒ‰éˆ•ç‚ºå•Ÿç”¨ç‹€æ…‹

    }catch(err){
        console.error('BLE é€£ç·šå¤±æ•—:', err);
        statusEl.textContent = `âŒ é€£ç·šå¤±æ•— (${err.message.slice(0, 30)}...)`;
        btnConnect.textContent = 'é€£ç·š BLE';
        // å¦‚æœé€£ç·šå¤±æ•—ï¼ŒåŸ·è¡Œæ–·ç·šæ¸…ç†é‚è¼¯
        onDisconnect(); 
    }
}


/**
 * å‘ ESP32 å‚³é€æ§åˆ¶æŒ‡ä»¤ (T,S)
 */
async function sendControl(){
    if(!characteristic || !device || !device.gatt.connected) {
        // å¦‚æœå·²æ–·ç·šï¼Œä¸å‚³é€å‘½ä»¤
        return;
    }

    const t_int = lastPayload.t;
    const s_int = lastPayload.s;

    // å»ºç«‹ payload æ ¼å¼: T,S (ä¾‹å¦‚: "255,0")
    const payload = `${t_int},${s_int}`;

    try{
        // æª¢æŸ¥ characteristic æ˜¯å¦æº–å‚™å¥½
        if (characteristic.properties.write) {
            await characteristic.writeValue(new TextEncoder().encode(payload));
        } else {
            console.error("Characteristic does not support 'write' property.");
        }
    }catch(err){
        console.warn('send failed (å¯èƒ½å·²æ–·ç·š):', err.message);
        // å¦‚æœå‚³é€å¤±æ•—ï¼Œä¸”è£ç½®ç‹€æ…‹é¡¯ç¤ºæœªé€£ç·šï¼Œå‰‡è§¸ç™¼æ–·ç·šè™•ç†
        if (device && device.gatt && !device.gatt.connected) {
            onDisconnect();
        }
    }
}

// --- Initialization ---

btnConnect.addEventListener('click', connectBLE);
btnSpeech.addEventListener('click', handleSpeechButtonClick);
updateMotorValues(0, 0, "éœæ­¢", "text-red-400"); // ç¢ºä¿åˆå§‹é¦¬é”ç‹€æ…‹ç‚ºéœæ­¢
updateSpeechUI(false, false); // ç¢ºä¿åˆå§‹èªéŸ³æŒ‰éˆ•ç‹€æ…‹ç‚ºæœªé€£ç·š
</script>
</body>
</html>