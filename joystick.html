<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1" />
  <title>BLE 搖桿控制 (Mobile)</title>
  <!-- 引入 Tailwind CSS 以實現更好的響應式設計和美化 -->
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    /* 使用 Inter 或系統字體以獲得最佳移動體驗 */
    html,body{height:100%;margin:0;font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Noto Sans TC', 'Inter', sans-serif; -webkit-touch-callout:none;-webkit-user-select:none; background-color: #f7f7f7;}
    .app{display:flex;flex-direction:column;align-items:center;justify-content:flex-start;padding:12px;gap:12px; height: 100%; box-sizing: border-box;}
    .top{width:100%;display:flex;gap:8px;align-items:center; max-width: 520px;}
    
    /* 美化按鈕 */
    button{padding:10px 14px;border-radius:12px;border:none;background:#2563EB;color:white;font-weight:700;box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); transition: all 0.15s ease-in-out;}
    button:hover { background: #1e40af; box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1);}
    
    #status{flex:1;text-align:center;font-weight:600;color:#333; padding: 10px; background: #fff; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.05);}
    
    .joystick-wrap{width:90vw;max-width:520px;height:66vh;display:flex;align-items:center;justify-content:center; flex-grow: 1; margin-top: 20px;}
    .pad{width:84vw;max-width:420px;height:84vw;max-height:420px;border-radius:999px;background:linear-gradient(180deg,#f3f3f3,#e6e6e6);position:relative;touch-action:none; border: 4px solid #ccc; box-shadow: inset 0 0 10px rgba(0,0,0,0.1), 0 5px 15px rgba(0,0,0,0.1);}
    .stick{position:absolute;width:30%;height:30%;max-width:150px;max-height:150px;border-radius:999px;background:rgba(40,40,40,0.85);transform:translate(-50%,-50%);left:50%;top:50%;display:flex;align-items:center;justify-content:center;color:white;font-weight:700;box-shadow: 0 4px 10px rgba(0,0,0,0.5);}
    .info{font-size:14px;color:#444; margin-bottom: 20px;}
  </style>
</head>
<body>
  <div class="app">
    <div class="top">
      <button id="btnConnect">連線 BLE</button>
      <div id="status">未連線</div>
    </div>

    <div class="joystick-wrap">
      <div class="pad" id="pad">
        <div class="stick" id="stick">0,0</div>
      </div>
    </div>

    <div class="info">說明：上/下推控制前/後（throttle），左右推控制轉向（steer）。每 60 ms 傳一次指令。Payload 格式：T (整數), S (整數)。</div>
  </div>

<script>
// --- UUIDs (與 ESP32 端需一致, 且必須是小寫) ---
// BLE 控制服務 UUID
const SERVICE_UUID = '4fafc201-1fb5-459e-8fcc-000000000000'; 
// 用於寫入 (Write) 控制指令的特徵 UUID
const CHARACTERISTIC_UUID = '4fafc201-1fb5-459e-8fcc-000000000000'; 
// 用於儲存裝置 ID 的 key
const DEVICE_ID_KEY = 'ble_joystick_device_id'; 
// 整數轉換的範圍上限 (例如: 8-bit 或 16-bit)
const MAX_CONTROL_VALUE = 255; 

// 狀態變數
let device = null;
let characteristic = null;
let sendingInterval = null;
let lastPayload = {t:0.0,s:0.0}; // 儲存油門(throttle)和轉向(steer)的浮點數值 (-1.0 to 1.0)

// DOM 元素
const pad = document.getElementById('pad');
const stick = document.getElementById('stick');
const status = document.getElementById('status');
const btnConnect = document.getElementById('btnConnect');

let rect, centerX, centerY, maxRadius;

// --- 搖桿與 UI 邏輯 ---

function resize() {
  rect = pad.getBoundingClientRect();
  centerX = rect.left + rect.width/2;
  centerY = rect.top + rect.height/2;
  maxRadius = rect.width/2 * 0.85; 
}
window.addEventListener('resize', resize);
resize();

let pointerActive = false;
function clamp(v,min,max){return Math.max(min,Math.min(max,v));}

/**
 * 將觸摸/滑鼠位置轉換為油門(T)和轉向(S)值 (-1.0 到 1.0)
 */
function pointerToTS(px,py){
  const dx = px - centerX;
  const dy = centerY - py; 
  const dist = Math.sqrt(dx*dx+dy*dy);
  const limitedDistRatio = clamp(dist / maxRadius, 0, 1);
  const normalizedX = dx / maxRadius;
  const normalizedY = dy / maxRadius;
  const throttle = clamp(normalizedY, -1, 1) * limitedDistRatio;
  const steer = clamp(normalizedX, -1, 1) * limitedDistRatio;
  return {
    t: throttle, 
    s: steer 
  };
}

/**
 * 更新搖桿圓點 (stick) 的位置
 */
function updateStick(px,py){
  const dx = px - centerX;
  const dy = py - centerY;
  const dist = Math.sqrt(dx*dx+dy*dy);
  const angle = Math.atan2(dy,dx);
  const limited = Math.min(dist, maxRadius);
  const x = centerX + Math.cos(angle)*limited;
  const y = centerY + Math.sin(angle)*limited;
  
  stick.style.left = (x - rect.left) + 'px';
  stick.style.top = (y - rect.top) + 'px';
}

/**
 * 將搖桿重置回中心點
 */
function resetStick(){
  stick.style.left = '50%';
  stick.style.top = '50%';
  stick.textContent = '0,0'; // 顯示整數格式
}

// Touch / Pointer handling
pad.addEventListener('pointerdown', (e)=>{
  pointerActive = true;
  pad.setPointerCapture(e.pointerId);
  resize();
  const t = pointerToTS(e.clientX, e.clientY);
  lastPayload.t = t.t; lastPayload.s = t.s;
  updateStick(e.clientX, e.clientY);
  // 顯示整數值
  const t_int = Math.round(t.t * MAX_CONTROL_VALUE);
  const s_int = Math.round(t.s * MAX_CONTROL_VALUE);
  stick.textContent = `${t_int},${s_int}`;
});

pad.addEventListener('pointermove', (e)=>{
  if(!pointerActive) return;
  const t = pointerToTS(e.clientX, e.clientY);
  lastPayload.t = t.t; lastPayload.s = t.s;
  updateStick(e.clientX, e.clientY);
  // 顯示整數值
  const t_int = Math.round(t.t * MAX_CONTROL_VALUE);
  const s_int = Math.round(t.s * MAX_CONTROL_VALUE);
  stick.textContent = `${t_int},${s_int}`;
});

pad.addEventListener('pointerup', (e)=>{
  if (!pointerActive) return;
  pointerActive = false;
  pad.releasePointerCapture(e.pointerId);
  lastPayload.t = 0.0; 
  lastPayload.s = 0.0; 
  resetStick();
});

// --- BLE 連線邏輯 ---

/**
 * 處理 BLE 斷線
 */
function onDisconnect() {
    status.textContent = '❌ 已斷線';
    btnConnect.textContent = '連線 BLE';
    if (sendingInterval) clearInterval(sendingInterval);
    sendingInterval = null;
    resetStick();
}

/**
 * 取得裝置物件 (透過掃描或快速重連)
 */
async function acquireDevice() {
    const storedDeviceId = localStorage.getItem(DEVICE_ID_KEY);

    if (storedDeviceId) {
        status.textContent = '嘗試使用 ID 快速連線...';
        try {
            const devices = await navigator.bluetooth.getDevices();
            const knownDevice = devices.find(d => d.id === storedDeviceId);

            if (knownDevice) {
                 status.textContent = `已找到儲存的裝置: ${knownDevice.name}`;
                 return knownDevice;
            }
        } catch (e) {
            console.warn("Could not retrieve known device:", e);
        }
    }
    
    status.textContent = '掃描中 (過濾: esp32)...';
    const newDevice = await navigator.bluetooth.requestDevice({
        filters:[{ namePrefix: 'esp32' }],
        optionalServices: [SERVICE_UUID] 
    });
    
    localStorage.setItem(DEVICE_ID_KEY, newDevice.id);
    return newDevice;
}


async function connectBLE(){
    if (!navigator.bluetooth) {
        status.textContent = '❌ 瀏覽器不支援 Web Bluetooth。';
        return;
    }
    
    if (device && device.gatt.connected) {
        device.gatt.disconnect();
        return;
    }

    try{
        if (!device) {
             device = await acquireDevice();
        } 
        
        if (!device) throw new Error("裝置未連線或未找到。");

        status.textContent = `連線到 ${device.name}...`;

        device.removeEventListener('gattserverdisconnected', onDisconnect);
        device.addEventListener('gattserverdisconnected', onDisconnect);

        const server = await device.gatt.connect();
        const service = await server.getPrimaryService(SERVICE_UUID);
        characteristic = await service.getCharacteristic(CHARACTERISTIC_UUID);
        
        status.textContent = '✅ 已連線: ' + device.name;
        btnConnect.textContent = '已連線 (斷開)';

        if(sendingInterval) clearInterval(sendingInterval);
        sendingInterval = setInterval(sendControl, 60);

    }catch(err){
        console.error('BLE 連線失敗:', err);
        status.textContent = `❌ 連線失敗 (${err.message.slice(0, 30)}...)`;
        btnConnect.textContent = '連線 BLE';
        clearInterval(sendingInterval);
        sendingInterval = null;
        
        if (device && !device.gatt.connected) {
            device = null;
            localStorage.removeItem(DEVICE_ID_KEY);
        }
    }
}


/**
 * 定期向 ESP32 傳送控制指令
 * *** 關鍵修改：將浮點數轉換為整數並格式化為 "T,S" 字串 ***
 */
async function sendControl(){
  if(!characteristic || !device || !device.gatt.connected) {
    if (sendingInterval) clearInterval(sendingInterval);
    sendingInterval = null;
    return;
  }
  
  // 1. 將 -1.0 到 1.0 的浮點數轉換為 -MAX_CONTROL_VALUE 到 MAX_CONTROL_VALUE 的整數
  const t_int = Math.round(lastPayload.t * MAX_CONTROL_VALUE);
  const s_int = Math.round(lastPayload.s * MAX_CONTROL_VALUE);
  
  // 2. 建立 payload 格式: T,S (例如: "200,0")
  const payload = `${t_int},${s_int}`;
  
  try{
    await characteristic.writeValue(new TextEncoder().encode(payload));
  }catch(err){
    console.warn('send failed (可能已斷線):', err.message);
  }
}

// --- 按鈕事件處理 ---
btnConnect.addEventListener('click', connectBLE);

// 初始設定
resetStick();
</script>
</body>
</html>